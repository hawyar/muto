{
  "version": 3,
  "sources": ["../lib/engine.ts"],
  "sourcesContent": ["import * as fs from \"fs\";\nimport * as os from \"os\";\nimport {createInterface} from \"readline\"\nimport {spawn} from \"child_process\";\nimport {fromIni} from \"@aws-sdk/credential-providers\"\nimport * as fastq from \"fastq\";\nimport type {queueAsPromised} from \"fastq\";\nimport path from \"path\";\nimport {readFileSync, writeFileSync} from 'atomically';\nimport {\n    S3Client,\n    GetObjectCommand,\n    S3ClientConfig,\n    CreateMultipartUploadCommand\n} from \"@aws-sdk/client-s3\";\n\ntype ShapeErrType = 'unrecognizedDelimiter' | 'noHeader' | 'invalidFileType' | 'rowWidthMismatch'\n\ntype supportedDelimiters = \",\" | \";\" | \"|\" | \":\" | \"\\t\" | \" \" | \"^\" | \"~\" | \"*\" | \"!\" | \"-\" | \"_\" | \"|\"\ntype env = 'local' | 'aws'\ntype connectorType = S3Client | fs.ReadStream\n\n// Shape of a dataset object\ninterface Shape {\n    type: string,\n    columns: Array<string>,\n    header: boolean,\n    encoding: string,\n    bom: boolean,\n    spanMultipleLines: boolean,\n    quotes: boolean,\n    delimiter: string,\n    errors: { [key: string]: string }\n    warnings: { [key: string]: string },\n    preview: string[][],\n}\n\n// Dataset represents a file from a supported a data source\ninterface Dataset {\n    source: string\n    options: Options;\n    shape?: Shape\n    data?: string[][];\n    createdAt: Date;\n    connector: connectorType;\n}\n\n// Options for a dataset\ninterface Options {\n    destination: string;\n    columns: Array<string>,\n    header: boolean,\n    bom: boolean,\n    delimiter: supportedDelimiters\n}\n\ntype Args = {\n    source: string,\n    options: Options\n}\n\n\nconst credentials = (profile: string) => fromIni({\n    profile: profile,\n    mfaCodeProvider: async (mfaSerial) => {\n        return mfaSerial\n    },\n});\n\nclass Dataset {\n    source: string\n    options: Options\n    createdAt: Date\n    connector: connectorType\n\n    constructor(args: Args, connector: connectorType) {\n        this.source = args.source;\n        this.options = args.options;\n        this.createdAt = new Date();\n        this.connector = connector;\n    }\n}\n\ninterface Cache {\n    path: string\n    init: Date\n\n    get(key: string): Dataset\n\n    set(key: string, value: Dataset): void\n\n    has(key: string): boolean\n\n    delete(key: string): void\n\n    clear(): void\n\n    size(): number\n\n    keys(): string[]\n}\n\n\nconst queue = (function () {\n    let q: queueAsPromised<Dataset>;\n\n// this func is private by scope\n    async function worker(arg: any) {\n        console.log(arg)\n    }\n\n    return {\n        getInstance: () => {\n            if (!q) {\n                q = fastq.promise(worker, 10)\n            }\n            return q;\n        }\n    }\n})();\n\nconst cache = (function (): { getInstance: () => Cache } {\n    let cache: Cache;\n\n    function init() {\n        const cachePath = path.join(process.cwd(), '.muto-cache')\n\n        if (!fs.existsSync(cachePath)) {\n            writeFileSync(cachePath, JSON.stringify({}))\n        }\n\n        return {\n            init: new Date(),\n            path: cachePath,\n            get: (key: string): any => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n\n                if (cache[key] !== key) {\n                    throw new Error('Cache key does not match')\n                }\n                return cache[key]\n            },\n            set: (key: string, value: Dataset): string => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n\n                cache[key] = value\n                writeFileSync(cachePath, JSON.stringify(cache))\n                return key\n            },\n            has: (key: string): boolean => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n                return cache[key] === key\n            },\n            delete: (key: string) => {\n                const file = readFileSync(path.join(process.cwd(), '.muto-cache'))\n                const cache = JSON.parse(file.toString())\n\n                delete cache[key]\n\n                writeFileSync(cachePath, JSON.stringify(cache))\n            },\n            clear: () => {\n                const file = readFileSync(path.join(process.cwd(), '.muto-cache'))\n\n                writeFileSync(cachePath, JSON.stringify({}))\n            },\n            size: () => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n                return Object.keys(cache).length\n            },\n            keys: () => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n                return Object.keys(cache)\n            }\n        }\n    }\n\n    return {\n        getInstance: () => {\n            if (!cache) {\n                cache = init()\n            }\n            return cache\n        }\n    }\n})()\n\n// Represents a workflow with a list of datasets in a local or cloud env\nclass Workflow {\n    name: string;\n    datasets: Map<string, Dataset>;\n    readonly createdAt: Date;\n    env: env;\n    queue: queueAsPromised<Args>\n    cache: Cache\n\n    constructor(name: string) {\n        this.name = name;\n        this.datasets = new Map();\n        this.createdAt = new Date();\n        this.env = 'local';\n        this.queue = queue.getInstance();\n        this.cache = cache.getInstance()\n    }\n\n    // async #worker({source, options}: Args): Promise<Dataset> {\n    //     return new Promise((resolve, reject) => {\n    //         if (this.datasets.has(source)) {\n    //             reject(new Error(`Dataset ${options.destination} already exists in the workflow`).message);\n    //         }\n    //\n    //         if (options.destination === \"\") {\n    //             console.warn(`Dataset ${source} does not have a destination`);\n    //         }\n    //\n    //         if (options.destination && options.destination.startsWith(\"s3://\")) {\n    //             const exists = this.#existsInS3(source);\n    //\n    //             if (exists) {\n    //                 const conn = this.#s3Connector({\n    //                     credentials: credentials(\"default\"),\n    //                     region: \"us-east-2\",\n    //                 });\n    //                 const dataset = new Dataset({source, options}, conn);\n    //                 this.datasets.set(source, dataset);\n    //                 resolve(dataset);\n    //             }\n    //             reject(new Error(`Dataset ${source} does not exist in S3`));\n    //         }\n    //\n    //         console.log(\"passed me\")\n    //\n    //         if (\n    //             source.startsWith(\"/\") ||\n    //             source.startsWith(\"../\") ||\n    //             source.startsWith(\"./\")\n    //         ) {\n    //             if (!source.endsWith(\".csv\")) {\n    //                 reject(new Error(`${source} is not a CSV file`));\n    //             }\n    //\n    //             const dataset = new Dataset({source, options}, this.#fsConnector(source));\n    //\n    //             this.queue.push({source, options})\n    //             console.log(\"added to queue, curr len: \", this.queue.length)\n    //             this.datasets.set(source, dataset);\n    //             resolve(dataset);\n    //         }\n    //         reject(new Error(`Invalid source ${source} type`));\n    //     });\n    //\n    // }\n\n    /**\n     * List datasets in the workflow\n     * @param options\n     * @returns\n     */\n    list(): Dataset[] {\n        return Array.from(this.datasets.values());\n    }\n\n    /**\n     * Removes dataset from workflow\n     * @param source\n     * @param options\n     */\n    remove(dataset: Dataset) {\n        this.datasets.delete(dataset.source);\n    }\n\n    /**\n     * Add dataset to workflow\n     * @param source\n     * @param options\n     * @returns\n     */\n    add(source: string, opt: Options) {\n        // add the dataset to the queue\n        return new Promise((resolve, reject) => {\n            this.queue.push({source, options: opt})\n            console.log(\"added to queue, curr len: \", this.queue.length())\n        })\n        // return new Promise((resolve, reject) => {\n        //     if (this.datasets.has(source)) {\n        //         reject(new Error(`Dataset ${opt.destination} already exists in the workflow`).message);\n        //     }\n        //\n        //     if (opt.destination === \"\") {\n        //         console.warn(`Dataset ${source} does not have a destination`);\n        //     }\n        //\n        //     if (opt.destination && opt.destination.startsWith(\"s3://\")) {\n        //         const exists = this.#existsInS3(source);\n        //\n        //         if (exists) {\n        //             const conn = this.#s3Connector({\n        //                 credentials: credentials(\"default\"),\n        //                 region: \"us-east-2\",\n        //             });\n        //             const dataset = new Dataset({source, options: opt}, conn);\n        //\n        //             this.datasets.set(source, dataset);\n        //             resolve(dataset);\n        //         }\n        //         // push new dataset to the workflow\n        //         reject(new Error(`Dataset ${source} does not exist in S3`));\n        //     }\n        //\n        //     if (\n        //         source.startsWith(\"/\") ||\n        //         source.startsWith(\"../\") ||\n        //         source.startsWith(\"./\")\n        //     ) {\n        //         if (!source.endsWith(\".csv\")) {\n        //             reject(new Error(`${source} is not a CSV file`));\n        //         }\n        //\n        //         const dataset = new Dataset({source, options: opt}, this.#fsConnector(source));\n        //         this.datasets.set(source, dataset);\n        //         resolve(dataset);\n        //     }\n        //     reject(new Error(`Invalid source ${source} type`));\n        // });\n    }\n\n    /**\n     * Checks if file exists in a S3 bucket\n     * @param source\n     * @param options\n     * @returns\n     */\n    #existsInS3(source: string): boolean {\n        const {data, err} = this.#parseS3URI(source, {\n            file: true,\n        });\n\n        if (err || !data.file) {\n            console.error(`Invalid S3 URI: ${source}, URI must point to a file`);\n            return false;\n        }\n\n        const conn = this.#s3Connector({\n            credentials: credentials(\"default\"),\n            region: \"us-east-2\",\n        });\n\n        const getObjectCommand = new GetObjectCommand({\n            Bucket: data.bucket,\n            Key: data.file,\n        });\n\n        conn.send(getObjectCommand).then((res) => {\n                if (res.$metadata.httpStatusCode === 200 && res.ContentType === \"text/csv\") {\n                    return true\n                }\n                return false\n            }\n        ).catch((err) => {\n            console.error(err);\n            return false;\n        });\n        return false\n    }\n\n    /**\n     * Returns a readable stream for a local file\n     * @param path\n     * @returns {fs.Dirent[]}\n     */\n    #fsConnector(path: string): fs.ReadStream {\n        return fs.createReadStream(path);\n    }\n\n    /**\n     * Returns a S3 client\n     * @param opt - S3 client config\n     * @returns S3Client\n     */\n    #s3Connector(opt: S3ClientConfig): S3Client {\n        if (!opt.region) {\n            opt.region = 'us-east-2';\n        }\n        return new S3Client(opt);\n    }\n\n    /**\n     * Detects the shape of a CSV file to know as much as possible early on regardless of given options.\n     * @param  {string} path - Path to the file\n     * @returns S3Client\n     */\n    #detectShape(path: string): Shape {\n        const shape: Shape = {\n            type: '',\n            columns: [''],\n            header: false,\n            encoding: 'utf-8',\n            bom: false,\n            spanMultipleLines: false,\n            quotes: false,\n            delimiter: ',',\n            errors: {},\n            warnings: {},\n            preview: [['']],\n        };\n\n        if (!fs.existsSync(path)) {\n            throw new Error(`${path} does not exist, provide a valid path to a CSV file`)\n        }\n\n        if (os.platform() === \"win32\") {\n            console.error(`handle windows later`)\n            return shape;\n        }\n\n        const mime = spawn(\"file\", [path, \"--mime-type\"])\n\n        mime.stdout.on(\"data\", (data) => {\n            const type = data.toString().split(\":\")[1].trim();\n\n            if (type === \"text/csv\" || type === \"text/plain\") {\n                shape.type = type;\n            } else {\n                shape.errors[\"incorrectType\"] = `${path} is not a CSV file`;\n            }\n        });\n\n        mime.on(\"close\", (code) => {\n            if (code !== 0 || shape.type === \"\") {\n                console.warn(\"unable to use file() cmd\");\n            }\n        });\n\n        const readLine = createInterface({\n            input: fs.createReadStream(path),\n            crlfDelay: Infinity,\n        });\n\n        let count = 0;\n        const max = 20;\n\n        // to store the column header if it exists for further checks\n        const first = {\n            row: [''],\n            del: \"\",\n        };\n\n        // hold the previous line while rl proceeds to next line using \\r\\n as a delimiter\n        let previous = \"\";\n\n        // create an array of delimiter from supported delimiter\n        const delimiters = [\",\", \";\", \"\\t\", \"|\", \":\", \" \", \"|\"];\n\n        readLine.on(\"line\", (current) => {\n\n            if (count === 0) {\n                delimiters.forEach((d) => {\n                    if (current.split(d).length > 1) {\n                        first.row = current.split(d)\n                        first.del = d;\n                    }\n                });\n\n                if (first.del === \"\" || first.row.length <= 1) {\n                    shape.errors[\"unrecognizedDelimiter\"] = `${path} does not have a recognized delimiter`;\n                    shape.header = false;\n                }\n\n                const isDigit = /\\d+/;\n\n                // betting on numbers should not appear as header values\n                const hasDigitInHeader = first.row.some((el) => isDigit.test(el));\n\n                if (hasDigitInHeader) {\n                    shape.header = false;\n                    shape.warnings[\"noHeader\"] = `no header found`;\n                    count++;\n                    return;\n                }\n\n                shape.header = true;\n                shape.delimiter = first.del;\n                shape.columns = first.row;\n            }\n\n            if (count > 0 && count < max) {\n                // there is a chance the record spans next line\n                const inlineQuotes = current.split(`\"`).length - 1;\n\n                if (previous) {\n                    if (inlineQuotes % 2 !== 0) {\n                        // TODO: make sure previous + current\n                        // console.log(previous + l);\n                        shape.spanMultipleLines = true;\n                    }\n                }\n                // if odd number of quotes and consider escaped quotes such as: \"aaa\",\"b\"\"bb\",\"ccc\"\n                if (\n                    inlineQuotes % 2 !== 0 &&\n                    current.split(`\"\"`).length - 1 !== 1\n                ) {\n                    previous = current;\n                }\n\n                const width = current.split(first.del).length;\n\n                if (width !== first.row.length) {\n                    shape.errors['rowWidthMismatch'] = `row width mismatch`;\n                    return;\n                }\n                shape.preview.push(current.split(first.del));\n            }\n            count++;\n        });\n        return shape;\n    }\n\n    // check fileSize sync\n    checkFileSize(path: string): number {\n        const max = 1024 * 1024 * 50\n        if (!fs.existsSync(path)) {\n            throw new Error(`${path} does not exist, provide a valid path to a CSV file`)\n        }\n        const file = fs.statSync(path)\n\n\n        file.blocks = Math.ceil(file.size / 512)\n\n        return fs.statSync(path).size\n    }\n\n    // /**\n    //  * Initiates a multipart upload and returns an upload ID\n    //  * @returns {string} uploadID\n    //  * @private\n    //  */\n    // #uploadToS3(d: Dataset) {\n    //     // grab the connector of the dataset\n    //     const c = d.connector;\n    //\n    //\n    // }\n\n    /**\n     * Initiates a multipart upload and returns an upload ID\n     * @returns {string} uploadID\n     * @private\n     */\n    #initMultipartUpload(\n        d: Dataset,\n        bucket: string,\n        key: string\n    ): Promise<string> {\n        return new Promise((resolve, reject) => {\n            try {\n                const conn = this.#s3Connector({\n                    credentials: credentials(\"default\"),\n                    region: \"us-east-2\",\n                });\n\n                if (!(conn instanceof S3Client))\n                    throw new Error(`Invalid operation for ${d.source}`);\n\n                const command = new CreateMultipartUploadCommand({\n                    Bucket: bucket,\n                    ContentEncoding: \"utf8\",\n                    ContentType: \"text/csv\",\n                    Key: key,\n                });\n\n                conn\n                    .send(command)\n                    .then((data) => {\n                        if (data.UploadId) {\n                            resolve(data.UploadId);\n                        }\n                        reject(new Error(\"noop\"))\n                    })\n                    .catch((error) => {\n                        reject(error);\n                    })\n                    .finally(() => {\n                        console.log(\"init multipart upload\");\n                    });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    /**\n     * Parse (s3://) style uri\n     */\n    #parseS3URI(\n        uri: string,\n        options: {\n            file: boolean;\n        }\n    ): {\n        data: {\n            bucket: string;\n            key: string;\n            file: string;\n        };\n        err: string;\n    } {\n        const opt = {\n            file: options && options.file ? options.file : false,\n        };\n\n        if (!uri.startsWith(\"s3://\") || uri.split(\":/\")[0] !== \"s3\") {\n            throw new Error(\"Invalid S3 URI\");\n        }\n\n        let err = \"\";\n\n        const result = {\n            bucket: \"\",\n            key: \"\",\n            file: \"\",\n        };\n\n        const src = uri.split(\":/\")[1];\n        const [bucket, ...keys] = src.split(\"/\").splice(1);\n\n        result.bucket = bucket;\n        result.key = keys.join(\"/\");\n\n        keys.forEach((k, i) => {\n            if (i === keys.length - 1) {\n                const last = k.split(\".\").length;\n                if (opt.file && last === 1) err = `uri should be a given, given: ${uri}`;\n\n                if (!opt.file && last === 1) return;\n\n                if (!opt.file && last > 1) {\n                    err = `Invalid S3 uri, ${uri} should not end with a file name`;\n                    return;\n                }\n\n                if (!opt.file && k.split(\".\")[1] !== \"\" && last > 1)\n                    err = `${uri} should not be a file endpoint: ${k}`;\n\n                if (last > 1 && k.split(\".\")[1] !== \"\") result.file = k;\n            }\n        });\n        return {\n            data: result,\n            err: err,\n        };\n    }\n}\n\n/**\n * Returns a new workflow\n * @param {string} name - Name of the workflow\n * @returns {Workflow} - New workflow\n */\nexport function createWorkflow(name: string): Workflow {\n    return new Workflow(name);\n}\n\n"],
  "mappings": "qcAAA,qBACA,qBACA,2CACA,sCACA,wDACA,wBAEA,oBACA,6DACA,sGAqDA,GAAM,GAAc,AAAC,GAAoB,EAAQ,CAC7C,QAAS,EACT,gBAAiB,AAAO,GAAc,0BAClC,MAAO,OAsCf,GAAM,GAAS,UAAY,CACvB,GAAI,GAGJ,WAAsB,EAAU,gCAC5B,QAAQ,IAAI,KAGhB,MAAO,CACH,YAAa,IACJ,IACD,GAAI,AAAM,UAAQ,EAAQ,KAEvB,OAKb,EAAS,UAA0C,CACrD,GAAI,GAEJ,YAAgB,CACZ,GAAM,GAAY,EAAK,KAAK,QAAQ,MAAO,eAE3C,MAAK,AAAG,cAAW,IACf,EAAc,EAAW,KAAK,UAAU,KAGrC,CACH,KAAM,GAAI,MACV,KAAM,EACN,IAAK,AAAC,GAAqB,CACvB,GAAM,GAAO,EAAa,GACpB,EAAQ,KAAK,MAAM,EAAK,YAE9B,GAAI,EAAM,KAAS,EACf,KAAM,IAAI,OAAM,4BAEpB,MAAO,GAAM,IAEjB,IAAK,CAAC,EAAa,IAA2B,CAC1C,GAAM,GAAO,EAAa,GACpB,EAAQ,KAAK,MAAM,EAAK,YAE9B,SAAM,GAAO,EACb,EAAc,EAAW,KAAK,UAAU,IACjC,GAEX,IAAK,AAAC,GAAyB,CAC3B,GAAM,GAAO,EAAa,GAE1B,MAAO,AADO,MAAK,MAAM,EAAK,YACjB,KAAS,GAE1B,OAAQ,AAAC,GAAgB,CACrB,GAAM,GAAO,EAAa,EAAK,KAAK,QAAQ,MAAO,gBAC7C,EAAQ,KAAK,MAAM,EAAK,YAE9B,MAAO,GAAM,GAEb,EAAc,EAAW,KAAK,UAAU,KAE5C,MAAO,IAAM,CACT,GAAM,GAAO,EAAa,EAAK,KAAK,QAAQ,MAAO,gBAEnD,EAAc,EAAW,KAAK,UAAU,MAE5C,KAAM,IAAM,CACR,GAAM,GAAO,EAAa,GACpB,EAAQ,KAAK,MAAM,EAAK,YAC9B,MAAO,QAAO,KAAK,GAAO,QAE9B,KAAM,IAAM,CACR,GAAM,GAAO,EAAa,GACpB,EAAQ,KAAK,MAAM,EAAK,YAC9B,MAAO,QAAO,KAAK,KAK/B,MAAO,CACH,YAAa,IACJ,IACD,GAAQ,KAEL,OA3LnB,yBAiMA,OAAe,CAQX,YAAY,EAAc,CAwI1B,UAsCA,UASA,UAYA,UA6JA,UA6CA,UA5YI,KAAK,KAAO,EACZ,KAAK,SAAW,GAAI,KACpB,KAAK,UAAY,GAAI,MACrB,KAAK,IAAM,QACX,KAAK,MAAQ,EAAM,cACnB,KAAK,MAAQ,EAAM,cAwDvB,MAAkB,CACd,MAAO,OAAM,KAAK,KAAK,SAAS,UAQpC,OAAO,EAAkB,CACrB,KAAK,SAAS,OAAO,EAAQ,QASjC,IAAI,EAAgB,EAAc,CAE9B,MAAO,IAAI,SAAQ,CAAC,EAAS,IAAW,CACpC,KAAK,MAAM,KAAK,CAAC,SAAQ,QAAS,IAClC,QAAQ,IAAI,6BAA8B,KAAK,MAAM,YA6O7D,cAAc,EAAsB,CAChC,GAAM,GAAM,KAAO,KAAO,GAC1B,GAAI,CAAC,AAAG,aAAW,GACf,KAAM,IAAI,OAAM,GAAG,wDAEvB,GAAM,GAAO,AAAG,WAAS,GAGzB,SAAK,OAAS,KAAK,KAAK,EAAK,KAAO,KAE7B,AAAG,WAAS,GAAM,OApM7B,gBAAW,SAAC,EAAyB,CACjC,GAAM,CAAC,OAAM,OAAO,OAAK,KAAL,UAAiB,EAAQ,CACzC,KAAM,KAGV,GAAI,GAAO,CAAC,EAAK,KACb,eAAQ,MAAM,mBAAmB,+BAC1B,GAGX,GAAM,GAAO,OAAK,KAAL,UAAkB,CAC3B,YAAa,EAAY,WACzB,OAAQ,cAGN,EAAmB,GAAI,GAAiB,CAC1C,OAAQ,EAAK,OACb,IAAK,EAAK,OAGd,SAAK,KAAK,GAAkB,KAAK,AAAC,GACtB,EAAI,UAAU,iBAAmB,KAAO,EAAI,cAAgB,YAKtE,MAAM,AAAC,GACL,SAAQ,MAAM,GACP,KAEJ,IAQX,gBAAY,SAAC,EAA6B,CACtC,MAAO,AAAG,oBAAiB,IAQ/B,gBAAY,SAAC,EAA+B,CACxC,MAAK,GAAI,QACL,GAAI,OAAS,aAEV,GAAI,GAAS,IAQxB,gBAAY,SAAC,EAAqB,CAC9B,GAAM,GAAe,CACjB,KAAM,GACN,QAAS,CAAC,IACV,OAAQ,GACR,SAAU,QACV,IAAK,GACL,kBAAmB,GACnB,OAAQ,GACR,UAAW,IACX,OAAQ,GACR,SAAU,GACV,QAAS,CAAC,CAAC,MAGf,GAAI,CAAC,AAAG,aAAW,GACf,KAAM,IAAI,OAAM,GAAG,wDAGvB,GAAI,AAAG,eAAe,QAClB,eAAQ,MAAM,wBACP,EAGX,GAAM,GAAO,EAAM,OAAQ,CAAC,EAAM,gBAElC,EAAK,OAAO,GAAG,OAAQ,AAAC,GAAS,CAC7B,GAAM,GAAO,EAAK,WAAW,MAAM,KAAK,GAAG,OAE3C,AAAI,IAAS,YAAc,IAAS,aAChC,EAAM,KAAO,EAEb,EAAM,OAAO,cAAmB,GAAG,wBAI3C,EAAK,GAAG,QAAS,AAAC,GAAS,CACvB,AAAI,KAAS,GAAK,EAAM,OAAS,KAC7B,QAAQ,KAAK,8BAIrB,GAAM,GAAW,EAAgB,CAC7B,MAAO,AAAG,mBAAiB,GAC3B,UAAW,MAGX,EAAQ,EACN,EAAM,GAGN,EAAQ,CACV,IAAK,CAAC,IACN,IAAK,IAIL,EAAW,GAGT,EAAa,CAAC,IAAK,IAAK,IAAM,IAAK,IAAK,IAAK,KAEnD,SAAS,GAAG,OAAQ,AAAC,GAAY,CAE7B,GAAI,IAAU,EAAG,CACb,EAAW,QAAQ,AAAC,GAAM,CACtB,AAAI,EAAQ,MAAM,GAAG,OAAS,GAC1B,GAAM,IAAM,EAAQ,MAAM,GAC1B,EAAM,IAAM,KAIhB,GAAM,MAAQ,IAAM,EAAM,IAAI,QAAU,IACxC,GAAM,OAAO,sBAA2B,GAAG,yCAC3C,EAAM,OAAS,IAGnB,GAAM,GAAU,MAKhB,GAFyB,EAAM,IAAI,KAAK,AAAC,GAAO,EAAQ,KAAK,IAEvC,CAClB,EAAM,OAAS,GACf,EAAM,SAAS,SAAc,kBAC7B,IACA,OAGJ,EAAM,OAAS,GACf,EAAM,UAAY,EAAM,IACxB,EAAM,QAAU,EAAM,IAG1B,GAAI,EAAQ,GAAK,EAAQ,EAAK,CAE1B,GAAM,GAAe,EAAQ,MAAM,KAAK,OAAS,EAmBjD,GAjBI,GACI,EAAe,IAAM,GAGrB,GAAM,kBAAoB,IAK9B,EAAe,IAAM,GACrB,EAAQ,MAAM,MAAM,OAAS,IAAM,GAEnC,GAAW,GAKX,AAFU,EAAQ,MAAM,EAAM,KAAK,SAEzB,EAAM,IAAI,OAAQ,CAC5B,EAAM,OAAO,iBAAsB,qBACnC,OAEJ,EAAM,QAAQ,KAAK,EAAQ,MAAM,EAAM,MAE3C,MAEG,GAkCX,iBAAoB,SAChB,EACA,EACA,EACe,CACf,MAAO,IAAI,SAAQ,CAAC,EAAS,IAAW,CACpC,GAAI,CACA,GAAM,GAAO,OAAK,KAAL,UAAkB,CAC3B,YAAa,EAAY,WACzB,OAAQ,cAGZ,GAAI,CAAE,aAAgB,IAClB,KAAM,IAAI,OAAM,yBAAyB,EAAE,UAE/C,GAAM,GAAU,GAAI,GAA6B,CAC7C,OAAQ,EACR,gBAAiB,OACjB,YAAa,WACb,IAAK,IAGT,EACK,KAAK,GACL,KAAK,AAAC,GAAS,CACZ,AAAI,EAAK,UACL,EAAQ,EAAK,UAEjB,EAAO,GAAI,OAAM,WAEpB,MAAM,AAAC,GAAU,CACd,EAAO,KAEV,QAAQ,IAAM,CACX,QAAQ,IAAI,iCAEf,EAAP,CACE,EAAO,OAQnB,gBAAW,SACP,EACA,EAUF,CACE,GAAM,GAAM,CACR,KAAM,GAAW,EAAQ,KAAO,EAAQ,KAAO,IAGnD,GAAI,CAAC,EAAI,WAAW,UAAY,EAAI,MAAM,MAAM,KAAO,KACnD,KAAM,IAAI,OAAM,kBAGpB,GAAI,GAAM,GAEJ,EAAS,CACX,OAAQ,GACR,IAAK,GACL,KAAM,IAGJ,EAAM,EAAI,MAAM,MAAM,GACtB,CAAC,KAAW,GAAQ,EAAI,MAAM,KAAK,OAAO,GAEhD,SAAO,OAAS,EAChB,EAAO,IAAM,EAAK,KAAK,KAEvB,EAAK,QAAQ,CAAC,EAAG,IAAM,CACnB,GAAI,IAAM,EAAK,OAAS,EAAG,CACvB,GAAM,GAAO,EAAE,MAAM,KAAK,OAG1B,GAFI,EAAI,MAAQ,IAAS,GAAG,GAAM,iCAAiC,KAE/D,CAAC,EAAI,MAAQ,IAAS,EAAG,OAE7B,GAAI,CAAC,EAAI,MAAQ,EAAO,EAAG,CACvB,EAAM,mBAAmB,oCACzB,OAGJ,AAAI,CAAC,EAAI,MAAQ,EAAE,MAAM,KAAK,KAAO,IAAM,EAAO,GAC9C,GAAM,GAAG,oCAAsC,KAE/C,EAAO,GAAK,EAAE,MAAM,KAAK,KAAO,IAAI,GAAO,KAAO,MAGvD,CACH,KAAM,EACN,IAAK,IAUV,WAAwB,EAAwB,CACnD,MAAO,IAAI,GAAS",
  "names": []
}
