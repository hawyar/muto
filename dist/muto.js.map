{
  "version": 3,
  "sources": ["../lib/engine.ts"],
  "sourcesContent": ["import fs from \"fs\"\nimport {ChildProcessWithoutNullStreams, spawn} from \"child_process\"\nimport os from \"os\"\nimport path, {join} from \"path\"\nimport {VFile} from \"vfile\"\nimport {createInterface} from \"readline\"\nimport {CreateMultipartUploadCommand, PutObjectCommand, S3Client, S3ClientConfig} from \"@aws-sdk/client-s3\"\nimport {fromIni} from \"@aws-sdk/credential-providers\"\n\nenum Delimiter {\n    COMMA = \",\",\n    TAB = \"\\t\",\n    SPACE = \" \",\n    PIPE = \"|\",\n    SEMICOLON = \";\",\n    COLON = \":\"\n}\n\nconst mlr = join(process.cwd(), \"node_modules\", \".bin\", \"mlr@v6.0.0\")\n\ntype env = \"local\" | \"aws\"\ntype connectorType = S3Client | fs.ReadStream\ntype loaderType = S3Client | fs.ReadStream\n\n// TODO: better error message for warning and errors in transform\ntype catalogStateType =\n    | \"init\"\n    | \"transforming\"\n    | \"uploading\"\n    | \"cancelled\"\n    | \"uploaded\"\n    | \"ready\"\n\ntype ProcessResult = {\n    stdout: string\n    stderr: string\n    code: number\n}\n\ntype Shape = {\n    type: string\n    columns: Array<string>\n    header: boolean\n    encoding: string\n    bom: boolean\n    size: number\n    spanMultipleLines: boolean\n    quotes: boolean\n    delimiter: string\n    errors: { [key: string]: string }\n    warnings: { [key: string]: string }\n    preview: string[][]\n}\n\ntype CatalogOptions = {\n    name: string\n    destination: string\n    columns: Array<string>\n    header: boolean\n    quotes: boolean\n    output: \"csv\" | \"json\"\n    delimiter: Delimiter\n}\n\nconst sqlparser = join(\n    process.cwd(),\n    \"node_modules\",\n    \".bin\",\n    \"sqlparser@v0.1.4\"\n)\n\ntype ParsedStatement = {\n    Cache?: string\n    Comments?: string\n    Distinct?: string\n    Hints?: string\n    SelectExprs?: []\n    From?: []\n    Where?: string\n    GroupBy?: null\n    Having?: null\n    OrderBy?: []\n    Limit?: null\n    Lock?: \"\"\n}\n\nconst credentials = (profile: string) =>\n    fromIni({\n        profile: profile,\n        mfaCodeProvider: async (mfaSerial) => {\n            return mfaSerial\n        }\n    })\n\nlet s3: S3Client\n\nfunction s3Client(config: S3ClientConfig): S3Client {\n    if (!s3) {\n        console.log(\"setting up s3 client\")\n        s3 = new S3Client(config)\n    }\n    return s3\n}\n\nfunction parseS3Uri(\n    uri: string,\n    options: {\n        file: boolean\n    }\n): {\n    data: {\n        bucket: string\n        key: string\n        file: string\n    }\n    err: string\n} {\n    const opt = {\n        file: options && options.file ? options.file : false\n    }\n\n    if (!uri.startsWith(\"s3://\") || uri.split(\":/\")[0] !== \"s3\") {\n        throw new Error(`invalid-s3-uri: ${uri}`)\n    }\n\n    let err = \"\"\n    const result = {\n        bucket: \"\",\n        key: \"\",\n        file: \"\"\n    }\n\n    const src = uri.split(\":/\")[1]\n    const [bucket, ...keys] = src.split(\"/\").splice(1)\n\n    result.bucket = bucket\n    result.key = keys.join(\"/\")\n\n    keys.forEach((k, i) => {\n        if (i === keys.length - 1) {\n            const last = k.split(\".\").length\n            if (opt.file && last === 1)\n                err = `uri should be a given, given: ${uri}`\n\n            if (!opt.file && last === 1) return\n\n            if (!opt.file && last > 1) {\n                err = `Invalid S3 uri, ${uri} should not end with a file name`\n                return\n            }\n\n            if (!opt.file && k.split(\".\")[1] !== \"\" && last > 1)\n                err = `${uri} should not be a file endpoint: ${k}`\n\n            if (last > 1 && k.split(\".\")[1] !== \"\") result.file = k\n        }\n    })\n    return {\n        data: result,\n        err: err\n    }\n}\n\nclass Catalog {\n    name: string\n    source: string\n    options: CatalogOptions\n    destination: string\n    init: Date\n    env: env\n    state: catalogStateType\n    vfile: VFile\n    pcount: number\n\n    constructor(source: string, options: CatalogOptions) {\n        this.name =\n            options && options.name ? options.name : path.basename(source)\n        this.source = source\n        this.options = options\n        this.destination = options.destination\n        this.env = \"local\"\n        this.init = new Date()\n        this.state = \"init\"\n        this.pcount = 0\n        this.vfile = new VFile({path: this.source})\n    }\n\n    async toJson(): Promise<ChildProcessWithoutNullStreams> {\n        const json = this.exec(mlr, [\n            \"--icsv\",\n            \"--ojson\",\n            \"clean-whitespace\",\n            this.source\n        ])\n        if (!json.stdout) {\n            throw new Error(`failed to convert ${this.source} from CSV to JSON`)\n        }\n        return json\n    }\n\n    async toCSV(): Promise<ChildProcessWithoutNullStreams> {\n        const json = this.exec(mlr, [\"--icsv\", \"--ocsv\", \"cat\", this.source])\n        if (!json.stdout) {\n            throw new Error(`failed to convert ${this.source} from JSON to CSV`)\n        }\n        return json\n    }\n\n    async rowCount(): Promise<number> {\n        const count = await this.exec(mlr, [`--ojson`, `count`, this.source])\n\n        const rowCountExec = await this.promisifyProcessResult(count)\n\n        if (rowCountExec.code !== 0) {\n            throw new Error(`Error while counting rows: ${rowCountExec.stderr}`)\n        }\n\n        if (rowCountExec.stderr) {\n            throw new Error(rowCountExec.stderr)\n        }\n\n        const r = JSON.parse(rowCountExec.stdout)\n\n        if (r.length === 0) {\n            throw new Error(\"No rows found\")\n        }\n\n        return r[0].count\n    }\n\n    async getColumnHeader(): Promise<string[] | null> {\n        const res = await this.exec(mlr, [\n            `--icsv`,\n            `--ojson`,\n            `head`,\n            `-n`,\n            `1`,\n            this.source\n        ])\n\n        const colExec = await this.promisifyProcessResult(res)\n\n        if (colExec.code !== 0) {\n            return null\n        }\n\n        if (colExec.stderr) {\n            throw new Error(colExec.stderr)\n        }\n        const columns = JSON.parse(colExec.stdout)\n\n        if (columns.length === 0) {\n            return null\n        }\n\n        const first = Object.keys(columns[0])\n        this.vfile.data.columns = first\n        return first\n    }\n\n    async preview(count = 20, streamTo?: string): Promise<string[][] | string> {\n        let write: fs.WriteStream\n\n        const maxPreview = 1024 * 1024 * 10\n\n        const fsp = fs.promises\n        const stat = await fsp.stat(this.source)\n\n        if (\n            (streamTo &&\n                streamTo !== this.source &&\n                fs.createWriteStream(streamTo) instanceof fs.WriteStream) ||\n            stat.size > maxPreview\n        ) {\n            if (streamTo === undefined)\n                throw new Error(\"stream-destination-undefined\")\n            write = fs.createWriteStream(streamTo)\n\n            const previewExec = await this.exec(mlr, [\n                `--icsv`,\n                `--ojson`,\n                `head`,\n                `-n`,\n                count.toString(),\n                this.source\n            ])\n\n            previewExec.stdout.pipe(write)\n\n            console.warn(`\uD83D\uDC40 Preview saved to: ${streamTo}`)\n            return streamTo\n        }\n\n        const previewExec = await this.exec(mlr, [\n            `--icsv`,\n            `--ojson`,\n            `head`,\n            `-n`,\n            count.toString(),\n            this.source\n        ])\n\n        const prev = await this.promisifyProcessResult(previewExec)\n\n        if (prev.stderr) {\n            throw new Error(prev.stderr)\n        }\n\n        if (prev.code !== 0) {\n            throw new Error(`Error while executing mlr command`)\n        }\n\n        this.vfile.data.preview = JSON.parse(prev.stdout)\n        return JSON.parse(prev.stdout)\n    }\n\n    async detectShape(): Promise<void> {\n        const path = this.source\n        const shape: Shape = {\n            type: \"\",\n            size: 0,\n            columns: [],\n            header: false,\n            encoding: \"utf-8\",\n            bom: false,\n            spanMultipleLines: false,\n            quotes: false,\n            delimiter: \",\",\n            errors: {},\n            warnings: {},\n            preview: []\n        }\n\n        if (!fs.existsSync(path)) {\n            throw new Error(\n                `path-doesnt-exists: ${path} ,provide a valid path to a CSV file`\n            )\n        }\n\n        shape.size = fs.statSync(path).size\n\n        if (shape.size > 1024 * 1024 * 1024) {\n            throw new Error(\n                `file-size-exceeds-limit: ${path} is too large, please limit to under 1GB for now`\n            )\n        }\n\n        if (!fs.existsSync(path)) {\n            throw new Error(\n                `${path} does not exist, provide a valid path to a CSV file`\n            )\n        }\n\n        if (os.platform() === \"win32\") {\n            // todo: handle\n            throw new Error(`scream`)\n        }\n\n        const mime = this.exec(\"file\", [path, \"--mime-type\"])\n\n        const mimeRes = await this.promisifyProcessResult(mime)\n\n        if (mimeRes.stderr) {\n            throw new Error(`failed-to-detect-mime-type: ${mimeRes.stderr}`)\n        }\n\n        if (mimeRes.code !== 0) {\n            throw new Error(`failed-to-detect-mime-type: ${mimeRes.stderr}`)\n        }\n\n        shape.type = mimeRes.stdout.split(\":\")[1].trim()\n\n        const readLine = createInterface({\n            input: fs.createReadStream(path),\n            crlfDelay: Infinity\n        })\n\n        let count = 0\n        const max = 20\n\n        const first = {\n            row: [\"\"],\n            del: \"\"\n        }\n\n        let previous = \"\"\n\n        const delimiters = [\",\", \";\", \"\\t\", \"|\", \":\", \" \", \"|\"]\n\n        readLine.on(\"line\", (current) => {\n            if (count === 0) {\n                delimiters.forEach((d) => {\n                    if (current.split(d).length > 1) {\n                        first.row = current.split(d)\n                        first.del = d\n                    }\n                })\n\n                if (first.del === \"\" || first.row.length <= 1) {\n                    shape.errors[\n                        \"unrecognizedDelimiter\"\n                        ] = `${path} does not have a recognized delimiter`\n                    shape.header = false\n                }\n                const isDigit = /\\d+/\n\n                const hasDigitInHeader = first.row.some((el) => isDigit.test(el));\n\n\n                console.log(hasDigitInHeader)\n                // if (hasDigitInHeader) {\n                //     shape.header = false;\n                //     shape.warnings[\"noHeader\"] = `no header found`;\n                //     count++;\n                //     return;\n                // }\n\n                shape.header = true\n                shape.delimiter = first.del\n                shape.columns = first.row\n            }\n\n            if (count > 0 && count < max) {\n                // there is a chance the record spans next line\n                const inlineQuotes = current.split(`\"`).length - 1\n\n                if (previous) {\n                    if (inlineQuotes % 2 !== 0) {\n                        // TODO: make sure previous + current\n                        // console.log(previous + l);\n                        shape.spanMultipleLines = true\n                    }\n                }\n                // if odd number of quotes and consider escaped quotes such as: \"aaa\",\"b\"\"bb\",\"ccc\"\n                if (\n                    inlineQuotes % 2 !== 0 &&\n                    current.split(`\"\"`).length - 1 !== 1\n                ) {\n                    previous = current\n                }\n\n                const width = current.split(first.del).length\n\n                if (width !== first.row.length) {\n                    shape.errors[\"rowWidthMismatch\"] = `row width mismatch`\n                    return\n                }\n                shape.preview.push(current.split(first.del))\n            }\n            count++\n        })\n\n        readLine.on(\"close\", () => {\n            this.vfile.data.shape = shape\n        })\n    }\n\n    determineLoader(): void {\n        if (this.destination.startsWith(\"s3://\")) {\n            this.vfile.data.loader = s3Client({\n                credentials: credentials(\"default\"),\n                region: \"us-east-2\"\n            })\n            return\n        }\n\n        if (\n            this.source.startsWith(\"/\") ||\n            this.source.startsWith(\"../\") ||\n            this.source.startsWith(\"./\")\n        ) {\n            this.vfile.data.loader = fs.createReadStream(this.source)\n            return\n        }\n    }\n\n    determineConnector(): void {\n        switch (this.env) {\n            case \"local\":\n                if (!fs.existsSync(this.source)) {\n                    throw new Error(\n                        `file: ${this.source} not found, please provide a valid file path`\n                    )\n                }\n                this.vfile.data.connector = fs.createReadStream(this.source)\n                break\n\n            case \"aws\":\n                this.vfile.data.connector = s3Client({\n                    credentials: credentials(\"default\"),\n                    region: \"us-east-2\"\n                })\n                break\n\n            default:\n                throw new Error(`unsupported-source for: ${this.source}`)\n        }\n    }\n\n    determineEnv() {\n        this.vfile.data.source = this.source\n\n        if (\n            this.source.startsWith(\"/\") ||\n            this.source.startsWith(\"../\") ||\n            this.source.startsWith(\"./\")\n        ) {\n            this.env = \"local\"\n            return\n        }\n\n        if (this.source.startsWith(\"s3://\")) {\n            this.env = \"aws\"\n            return\n        }\n\n        throw new Error(`invalid-source-type: ${this.source}`)\n    }\n\n    fileSize(): number {\n        const max = 1024 * 1024 * 50\n\n        if (!fs.existsSync(this.source)) {\n            throw new Error(\n                `path-doesnt-exists: ${this.source} ,provide a valid path to a CSV file`\n            )\n        }\n\n        const stat = fs.statSync(this.source)\n\n        if (stat.size > max) {\n            throw new Error(\n                `file-size-exceeds-limit: ${this.source} is too large, please limit to 50MB`\n            )\n        }\n        return stat.size\n    }\n\n    async uploadToS3(): Promise<string> {\n        if (!this.source || !this.destination) {\n            throw new Error(\n                \"source or destination not set. Both must be defined to upload to S3\"\n            )\n        }\n\n        const fStream = fs.createReadStream(this.source)\n\n        if (!fStream.readable) {\n            throw new Error(\n                \"failed-to-read-source: Make sure the provided file is readable\"\n            )\n        }\n\n        const fSize = this.fileSize()\n\n        if (fSize > 100 * 1024 * 1024) {\n            //TODO: init multipart upload then upload parts\n            console.warn(`file size ${fSize} is larger than 100MB`)\n        }\n\n        const {data: uri, err} = parseS3Uri(this.destination, {\n            file: true\n        })\n\n        if (err.toString().startsWith(`invalid-s3-uri`)) {\n            throw new Error(`failed-to-parse-s3-uri: ${err}`)\n        }\n\n        if (!uri.file) {\n            uri.file = path.basename(this.source)\n            console.warn(\n                \"Destination filename not provided. Using source source basename\" +\n                uri.file\n            )\n        }\n\n        console.log(`uploading ${this.source} to ${this.destination}`)\n\n        const s3 = s3Client({\n            region: \"us-east-2\"\n        })\n\n        const res = await s3\n            .send(\n                new PutObjectCommand({\n                    Bucket: uri.bucket,\n                    Key: uri.key + uri.file,\n                    Body: fStream\n                })\n            )\n            .catch((err) => {\n                throw new Error(\n                    `failed-upload-s3: Error while uploading to S3: ${err}`\n                )\n            })\n            .finally(() => {\n                fStream.close()\n            })\n\n        if (res.$metadata.httpStatusCode !== 200) {\n            throw new Error(\n                `failed-upload-s3: Error while uploading to S3: ${res.$metadata.httpStatusCode}`\n            )\n        }\n\n        if (!res.$metadata.requestId)\n            throw new Error(\n                `failed-upload-s3: Error while uploading to S3: ${res.$metadata.httpStatusCode}`\n            )\n        return res.$metadata.requestId\n    }\n\n    async initMultipartUpload(bucket: string, key: string): Promise<string> {\n        const client = s3Client({\n            credentials: credentials(\"default\"),\n            region: \"us-east-2\"\n        })\n\n        const command = new CreateMultipartUploadCommand({\n            Bucket: bucket,\n            ContentEncoding: \"utf8\",\n            ContentType: \"text/csv\",\n            Key: key\n        })\n\n        const result = await client.send(command)\n\n        if (result.$metadata.httpStatusCode !== 200) {\n            throw new Error(\n                `failed-multipart-upload: Error while creating multipart upload: ${result.UploadId} with status code ${result.$metadata.httpStatusCode}`\n            )\n        }\n\n        if (!result.UploadId) {\n            throw new Error(\n                `failed-multipart-upload: Error while creating multipart upload: ${result.UploadId}`\n            )\n        }\n\n        return result.UploadId\n    }\n\n    exec(cmd: string, args: string[]): ChildProcessWithoutNullStreams {\n        console.log(`exec: ${cmd} ${args.join(\" \")}`)\n\n        if (this.pcount > 5) {\n            throw new Error(`too-many-processes: ${this.pcount}`)\n        }\n\n        this.pcount++\n        return spawn(cmd, args, {})\n    }\n\n    promisifyProcessResult(\n        child: ChildProcessWithoutNullStreams\n    ): Promise<ProcessResult> {\n        const result: ProcessResult = {\n            stdout: \"\",\n            stderr: \"\",\n            code: 0\n        }\n\n        return new Promise((resolve, reject) => {\n            child.stdout.on(\"data\", (data) => {\n                result.stdout += data\n            })\n\n            child.stderr.on(\"data\", (data) => {\n                result.stderr += data\n            })\n\n            child.on(\"close\", (code) => {\n                result.code = code === 0 ? 0 : 1\n                resolve(result)\n            })\n\n            child.on(\"error\", (err) => {\n                reject(err)\n            })\n        })\n    }\n}\n\nexport async function createCatalog(\n    source: string,\n    opt: CatalogOptions\n): Promise<Catalog> {\n    return new Promise((resolve, reject) => {\n        if (!source) {\n            reject(new Error(`failed-to-create-dataset: source is required`))\n        }\n\n        if (!opt || !opt.destination) {\n            reject(\n                new Error(`failed-to-create-dataset: destination is required`)\n            )\n        }\n\n        if (!source.endsWith(\".csv\")) {\n            reject(\n                new Error(\n                    `failed to create dataset: ${source}, source must be a csv file`\n                )\n            )\n        }\n\n        const catalog = new Catalog(source, opt)\n\n        Promise.all([\n            catalog.determineEnv(),\n            catalog.detectShape(),\n            catalog.determineConnector(),\n            catalog.determineLoader()\n        ])\n            .then(() => {\n                console.log(`created catalog for ${source}`)\n                resolve(catalog)\n            })\n            .catch((err) => reject(err))\n    })\n}\n\nclass Workflow {\n    name: string\n    catalogs: Map<string, Catalog>\n    readonly createdAt: Date\n    env: env\n    stmt: string // sql statement\n\n    constructor(name: string) {\n        this.name = name\n        this.catalogs = new Map()\n        this.createdAt = new Date()\n        this.env = \"local\"\n        this.stmt = \"\"\n    }\n\n    list(): Catalog[] {\n        return Array.from(this.catalogs.values())\n    }\n\n    remove(dataset: Catalog) {\n        this.catalogs.delete(dataset.source)\n    }\n\n    get(source: string): Catalog | null {\n        return this.catalogs.get(source) || null\n    }\n\n    add(c: Catalog): string {\n        if (this.catalogs.has(c.source)) {\n            throw new Error(\n                `${c.source} already exists in workflow ${this.name}`\n            )\n        }\n\n        this.catalogs.set(c.source, c)\n\n        console.log(`added ${c.source} to the workflow`)\n\n        return c.source\n    }\n\n    async query(raw: string): Promise<ParsedStatement> {\n        console.log(`parsing statement: ${raw}`)\n\n        let result: ParsedStatement = {}\n\n        const child = spawn(sqlparser, [raw])\n\n        return new Promise((resolve, reject) => {\n            child.on(\"error\", (err) => {\n                reject(err)\n            })\n\n            child.stdout.on(\"data\", (data) => {\n                const parsed = JSON.parse(data.toString())\n                if (parsed.error) {\n                    reject(\n                        `failed-sqlparser: Error while parsing query: ${parsed.error}`\n                    )\n                }\n                result = parsed\n            })\n\n            child.on(\"close\", (code) => {\n                if (code !== 0) {\n                    reject(\n                        `failed-sqlparser: Error while parsing query: ${code}`\n                    )\n                }\n                console.log(JSON.stringify(result, null, 2))\n                resolve(result)\n            })\n        })\n    }\n}\n\nexport function createWorkflow(name: string): Workflow {\n    return new Workflow(name)\n}\n"],
  "mappings": "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",
  "names": []
}
