{
  "version": 3,
  "sources": ["../lib/engine.ts"],
  "sourcesContent": ["import * as fs from \"fs\";\nimport {createInterface, Interface} from \"readline\";\nimport path from \"path\";\nimport {readFileSync, writeFileSync} from 'atomically';\nimport {CreateMultipartUploadCommand, GetObjectCommand, S3Client, S3ClientConfig} from \"@aws-sdk/client-s3\";\nimport {fromIni} from \"@aws-sdk/credential-providers\";\nimport {ChildProcessWithoutNullStreams, spawn} from \"child_process\";\nimport os from \"os\";\n\nenum Delimiters {\n    COMMA = \",\",\n    SEMICOLON = \";\",\n    PIPE = \"|\",\n    COLON = \":\",\n    TAB = \"\\t\",\n    SPACE = \" \",\n    TILDE = \"~\",\n    DASH = \"-\",\n    UNDERSCORE = \"_\"\n}\n\n\ntype env = 'local' | 'remote'\ntype connectorType = S3Client | fs.ReadStream\n\n\n// TODO: better error message for errors in transform\ntype datasetStateType = 'init' | 'transforming' | 'uploading' | 'cancelled' | 'uploaded' | 'ready'\ntype ShapeErrType = 'unrecognizedDelimiter' | 'noHeader' | 'invalidFileType' | 'rowWidthMismatch'\n\n\ninterface Shape {\n    type: string,\n    columns: Array<string>,\n    header: boolean,\n    encoding: string,\n    bom: boolean,\n    spanMultipleLines: boolean,\n    quotes: boolean,\n    delimiter: string,\n    errors: { [key: string]: string }\n    warnings: { [key: string]: string },\n    preview: string[][],\n}\n\ninterface Dataset {\n    source: string\n    cached: boolean\n    options: DatasetOptions;\n    destination: string\n    shape: Shape\n    createdAt: Date;\n    state: datasetStateType\n    connector: connectorType;\n}\n\ninterface DatasetOptions {\n    destination: string;\n    columns: Array<string>,\n    header: boolean,\n    quotes: boolean,\n    transform: (row: object) => object\n    delimiter: Delimiters\n}\n\ninterface Cache {\n    path: string\n    init: Date\n\n    get(key: string): Dataset | undefined\n\n    set(key: string, value: Dataset): void\n\n    has(key: string): boolean\n\n    delete(key: string): void\n\n    clear(): void\n\n    size(): number\n\n    keys(): string[]\n}\n\ntype ProcessResult = {\n    stdout: string,\n    stderr: string,\n    code: number\n}\n\n\nconst credentials = (profile: string) => fromIni({\n    profile: profile,\n    mfaCodeProvider: async (mfaSerial) => {\n        return mfaSerial\n    },\n});\n\n\nconst mlrCmd = path.join(process.cwd(), 'node_modules', '.bin', 'mlr@v6.0.0')\n\n\nclass Dataset {\n    source: string\n    destination: string\n    _rowsCount: number\n    options: DatasetOptions\n    createdAt: Date\n    shape: Shape\n    state: datasetStateType\n    processCount: number\n    cached: boolean\n\n    constructor(source: string, options: DatasetOptions) {\n        this.source = source;\n        this.cached = false;\n        this._rowsCount = 0;\n        this.destination = options.destination || process.cwd()\n        this.options = options;\n        this.shape = {\n            type: '',\n            columns: [],\n            header: false,\n            encoding: '',\n            bom: false,\n            spanMultipleLines: false,\n            quotes: false,\n            delimiter: '',\n            errors: {},\n            warnings: {},\n            preview: []\n        }\n        this.createdAt = new Date();\n        this.state = 'init'\n        this.processCount = 0\n    }\n\n    async toJson(): Promise<string> {\n        const write = fs.createWriteStream(this.destination)\n\n        const json = this.#exec(mlrCmd, [\"--icsv\", \"--ojson\", \"clean-whitespace\", \"cat\", this.source])\n\n        json.stdout.pipe(write)\n\n        return new Promise((resolve, reject) => {\n            write.on('close', () => {\n                resolve(this.source)\n            })\n            write.on('error', (err) => {\n                reject(err)\n            })\n        })\n    }\n\n    async rowsCount(): Promise<number> {\n        const res = await this.#exec(mlrCmd, [`--ojson`, `count`, this.source])\n\n        const rowCountExec = await this.#promisifyProcessResult(res)\n\n        if (rowCountExec.code !== 0) {\n            throw new Error(`Error while counting rows: ${rowCountExec.stderr}`)\n        }\n\n        if (rowCountExec.stderr) {\n            throw new Error(rowCountExec.stderr)\n        }\n\n        const r = JSON.parse(rowCountExec.stdout)\n\n        if (r.length === 0) {\n            throw new Error('No rows found')\n        }\n        this._rowsCount = r[0].count\n        return r[0].count\n    }\n\n    async columns(): Promise<string[] | null> {\n        const res = await this.#exec(mlrCmd, [`--icsv`, `--ojson`, `head`, `-n`, `1`, this.source])\n\n        const colExec = await this.#promisifyProcessResult(res)\n\n        if (colExec.code !== 0) {\n            return null\n        }\n\n        if (colExec.stderr) {\n            throw new Error(colExec.stderr)\n        }\n        const columns = JSON.parse(colExec.stdout)\n\n\n        if (columns.length === 0) {\n            this.shape.header = false\n            return null\n        }\n\n        this.shape.columns = Object.keys(columns[0])\n        this.shape.header = true\n\n        return this.shape.columns\n    }\n\n    async preview(count: number, streamTo?: string): Promise<string[][] | string> {\n\n        let write: fs.WriteStream\n\n        const maxPreview = 1024 * 1024 * 10\n\n        const fsp = fs.promises\n        const stat = await fsp.stat(this.source)\n\n        if (streamTo && streamTo !== this.source && fs.createWriteStream(streamTo) instanceof fs.WriteStream || stat.size > maxPreview) {\n            try {\n                if (streamTo === undefined) throw new Error('stream-destination-undefined')\n                write = fs.createWriteStream(streamTo)\n            } catch (err) {\n                throw new Error(`${streamTo} is not writable`)\n            }\n\n            const previewExec = await this.#exec(mlrCmd, [`--icsv`, `--ojson`, `head`, `-n`, count.toString(), this.source])\n            previewExec.stdout.pipe(write)\n\n            console.warn(`\uD83D\uDC40 Preview saved to: ${streamTo}`)\n            return streamTo\n        }\n\n        const previewExec = await this.#exec(mlrCmd, [`--icsv`, `--ojson`, `head`, `-n`, count.toString(), this.source])\n\n        const prev = await this.#promisifyProcessResult(previewExec)\n\n        if (prev.stderr) {\n            throw new Error(prev.stderr)\n        }\n\n        if (prev.code !== 0) {\n            throw new Error(`Error while executing mlr command`)\n        }\n\n        const parsed = JSON.parse(prev.stdout)\n        this.shape.preview = parsed\n\n        return this.shape.preview\n    }\n\n    #promisifyProcessResult(child: ChildProcessWithoutNullStreams): Promise<ProcessResult> {\n        const result: ProcessResult = {\n            stdout: '',\n            stderr: '',\n            code: 0\n        }\n\n        return new Promise((resolve, reject) => {\n            child.stdout.on('data', (data) => {\n                result.stdout += data\n            })\n\n            child.stderr.on('data', (data) => {\n                result.stderr += data\n            })\n\n            child.on('close', (code) => {\n                result.code = code === 0 ? 0 : 1\n                resolve(result)\n            })\n\n            child.on('error', (err) => {\n                reject(err)\n            })\n        })\n    }\n\n\n    #exec(cmd: string, args: string[]): ChildProcessWithoutNullStreams {\n        this.processCount++\n        return spawn(cmd, args)\n    }\n\n    async #fileType(): Promise<void> {\n        const path = this.source;\n\n        if (!fs.existsSync(path)) {\n            throw new Error(`${path} does not exist, provide a valid path to a CSV file`)\n        }\n\n        if (os.platform() === \"win32\") {\n            // TODO: handle\n            return;\n        }\n\n        const mime = this.#exec(\"file\", [path, \"--mime-type\"])\n\n        mime.stdout.on(\"data\", (data) => {\n            const type = data.toString().split(\":\")[1].trim();\n\n            if (type === \"text/csv\" || type === \"text/plain\") {\n                this.shape.type = type;\n            } else {\n                this.shape.errors[\"incorrectType\"] = `${path} is not a CSV file`;\n            }\n        });\n\n        mime.stderr.on(\"error\", (err) => {\n            console.warn(err);\n        });\n\n        mime.on(\"close\", (code) => {\n            if (code !== 0 || this.shape.type === \"\") {\n                console.warn(\"unable to use file() cmd\");\n            }\n        });\n    }\n}\n\n\nconst cache = (function (): { getInstance: () => Cache } {\n    let cache: Cache;\n\n    function init() {\n        const cachePath = path.join(process.cwd(), '.muto-cache')\n\n        if (!fs.existsSync(cachePath)) {\n            console.log('creating cache file at', cachePath)\n            writeFileSync(cachePath, JSON.stringify({}))\n        } else {\n            console.log('loading cache from', cachePath)\n        }\n\n        return {\n            init: new Date(),\n            path: cachePath,\n            get: (key: string): Dataset | undefined => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n\n                if (cache[key].source !== key) {\n                    return undefined\n                }\n                return cache[key]\n            },\n            set: (key: string, value: Dataset): string | void => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n\n                if (cache[key]) {\n                    return\n                }\n\n                cache[key] = value\n                writeFileSync(cachePath, JSON.stringify(cache))\n                return key\n            },\n            has: (key: string): boolean => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n\n                if (cache[key]) {\n                    return true\n                }\n                return false\n            },\n            delete: (key: string) => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n\n                delete cache[key]\n\n                writeFileSync(cachePath, JSON.stringify(cache))\n            },\n            clear: () => {\n                writeFileSync(cachePath, JSON.stringify({}))\n            },\n            size: () => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n                return Object.keys(cache).length\n            },\n            keys: () => {\n                const file = readFileSync(cachePath)\n                const cache = JSON.parse(file.toString())\n                return Object.keys(cache)\n            }\n        }\n    }\n\n    return {\n        getInstance: () => {\n            if (!cache) {\n                cache = init()\n            }\n            return cache\n        }\n    }\n})()\n\nfunction s3Connector(config: S3ClientConfig) {\n    const client = new S3Client(config);\n    return Object.freeze({\n        getObject: (command: GetObjectCommand) => client.send(command),\n        createMultipartUpload: (command: CreateMultipartUploadCommand) => client.send(command),\n    });\n}\n\nfunction fsConnector(filePath: string) {\n    return Object.freeze({\n        readStream(): Promise<fs.ReadStream> {\n            return new Promise((resolve, reject) => {\n                const stream = fs.createReadStream(filePath);\n                stream.on('error', (err) => {\n                    reject(err);\n                });\n                stream.on('open', () => {\n                    resolve(stream);\n                });\n            });\n        },\n        writeStream(): Promise<fs.WriteStream> {\n            return new Promise((resolve, reject) => {\n                const stream = fs.createWriteStream(filePath);\n                stream.on('error', (err) => {\n                    reject(err);\n                });\n                stream.on('open', () => {\n                    resolve(stream);\n                });\n            });\n        },\n        readline(): Promise<Interface> {\n            return new Promise((resolve, reject) => {\n                const stream = fs.createReadStream(filePath);\n                stream.on('error', (err) => {\n                    reject(err);\n                });\n                stream.on('open', () => {\n                    const rl = createInterface({\n                        input: stream,\n                        crlfDelay: Infinity\n                    });\n                    resolve(rl);\n                });\n            });\n        },\n\n    })\n}\n\n\nclass Workflow {\n    name: string;\n    datasets: Map<string, Dataset>;\n    readonly createdAt: Date;\n    env: env;\n    lcache: Cache\n\n    constructor(name: string) {\n        this.name = name;\n        this.datasets = new Map();\n        this.createdAt = new Date();\n        this.env = 'local';\n        this.lcache = cache.getInstance()\n    }\n\n    list(): Dataset[] {\n        return Array.from(this.datasets.values());\n    }\n\n    remove(dataset: Dataset) {\n        this.datasets.delete(dataset.source);\n    }\n\n    async add(source: string, options: DatasetOptions): Promise<string> {\n        if (options.destination === \"\") {\n            console.warn(`destination-not-provided: provide a destination for ${source}`);\n        }\n\n        if (this.lcache.has(source)) {\n            return source\n        }\n\n        const dataset = new Dataset(source, options);\n\n        const defaultPreviewCount = 10\n\n        await Promise.all([dataset.columns(), dataset.preview(defaultPreviewCount), dataset.toJson()]);\n\n        console.log(dataset);\n        this.datasets.set(source, dataset);\n        this.lcache.set(source, dataset)\n        return source\n    }\n\n    /**\n     * Checks if file exists in a S3 bucket\n     * @param source\n     * @param options\n     * @returns\n     */\n    #existsInS3(source: string): boolean {\n        const {data, err} = this.#parseS3URI(source, {\n            file: true,\n        });\n\n        if (err || !data.file) {\n            console.error(`Invalid S3 URI: ${source}, URI must point to a file`);\n            return false;\n        }\n\n        const conn = this.#s3Connector({\n            credentials: credentials(\"default\"),\n            region: \"us-east-2\",\n        });\n\n        const getObjectCommand = new GetObjectCommand({\n            Bucket: data.bucket,\n            Key: data.file,\n        });\n\n        conn.send(getObjectCommand).then((res) => {\n                if (res.$metadata.httpStatusCode === 200 && res.ContentType === \"text/csv\") {\n                    return true\n                }\n                return false\n            }\n        ).catch((err) => {\n            console.error(err);\n            return false;\n        });\n        return false\n    }\n\n    #determineSource(source: string): string {\n        if (\n            source.startsWith(\"/\") ||\n            source.startsWith(\"../\") ||\n            source.startsWith(\"./\")\n        ) {\n            return \"local\";\n        }\n\n        if (source.startsWith(\"s3://\")) {\n            return \"s3\";\n        }\n\n        throw new Error(`invalid-source-type: ${source}`);\n    }\n\n    /**\n     * Returns a readable stream for a local file\n     * @param path\n     * @returns {fs.Dirent[]}\n     */\n    #fsConnector(path: string): fs.ReadStream {\n        return fs.createReadStream(path);\n    }\n\n    #s3Connector(opt: S3ClientConfig): S3Client {\n        if (!opt.region) {\n            opt.region = 'us-east-2';\n        }\n        return new S3Client(opt);\n    }\n\n\n    #checkFileSize(path: string): number {\n        const max = 1024 * 1024 * 50\n        if (!fs.existsSync(path)) {\n            throw new Error(`path-doesnt-exists: ${path} ,provide a valid path to a CSV file`)\n        }\n        const file = fs.statSync(path)\n\n        if (file.size > max) {\n            throw new Error(`file-size-exceeds-limit: ${path} is too large, please limit to 50MB`)\n        }\n        return fs.statSync(path).size\n    }\n\n    /**\n     * Initiates a multipart upload and returns an upload ID\n     * @returns {string} uploadID\n     * @private\n     */\n    #initMultipartUpload(\n        d: Dataset,\n        bucket: string,\n        key: string\n    ): Promise<string> {\n        return new Promise((resolve, reject) => {\n            try {\n                const conn = this.#s3Connector({\n                    credentials: credentials(\"default\"),\n                    region: \"us-east-2\",\n                });\n\n                if (!(conn instanceof S3Client))\n                    // TODO: dont throw here, throw in the caller\n                    throw new Error(`invalid-operation: Invalid operation for ${d.source}`);\n\n                const command = new CreateMultipartUploadCommand({\n                    Bucket: bucket,\n                    ContentEncoding: \"utf8\",\n                    ContentType: \"text/csv\",\n                    Key: key,\n                });\n\n                conn\n                    .send(command)\n                    .then((data) => {\n                        if (data.UploadId) {\n                            resolve(data.UploadId);\n                        }\n                        reject(new Error(\"noop\"))\n                    })\n                    .catch((error) => {\n                        reject(error);\n                    })\n                    .finally(() => {\n                        console.log(\"init multipart upload\");\n                    });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    #parseS3URI(\n        uri: string,\n        options: {\n            file: boolean;\n        }\n    ): {\n        data: {\n            bucket: string;\n            key: string;\n            file: string;\n        };\n        err: string;\n    } {\n        const opt = {\n            file: options && options.file ? options.file : false,\n        };\n\n        if (!uri.startsWith(\"s3://\") || uri.split(\":/\")[0] !== \"s3\") {\n            throw new Error(`invalid-s3-uri: ${uri}`);\n        }\n\n        let err = \"\";\n\n        const result = {\n            bucket: \"\",\n            key: \"\",\n            file: \"\",\n        };\n\n        const src = uri.split(\":/\")[1];\n        const [bucket, ...keys] = src.split(\"/\").splice(1);\n\n        result.bucket = bucket;\n        result.key = keys.join(\"/\");\n\n        keys.forEach((k, i) => {\n            if (i === keys.length - 1) {\n                const last = k.split(\".\").length;\n                if (opt.file && last === 1) err = `uri should be a given, given: ${uri}`;\n\n                if (!opt.file && last === 1) return;\n\n                if (!opt.file && last > 1) {\n                    err = `Invalid S3 uri, ${uri} should not end with a file name`;\n                    return;\n                }\n\n                if (!opt.file && k.split(\".\")[1] !== \"\" && last > 1)\n                    err = `${uri} should not be a file endpoint: ${k}`;\n\n                if (last > 1 && k.split(\".\")[1] !== \"\") result.file = k;\n            }\n        });\n        return {\n            data: result,\n            err: err,\n        };\n    }\n}\n\n/**\n * Returns a new workflow\n * @param {string} name - Name of the workflow\n * @returns {Workflow} - New workflow\n */\nfunction createWorkflow(name: string): Workflow {\n    return new Workflow(name);\n}\n\n\n/**\n * Returns a new dataset\n * @param {string} name - Source of the dataset\n * @returns {Options} - Options for the dataset\n */\nfunction createDataset(source: string, options: DatasetOptions): Dataset {\n    return new Dataset(source, options);\n}\n\n\nexport {\n    createDataset,\n    createWorkflow,\n}"],
  "mappings": "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",
  "names": []
}
